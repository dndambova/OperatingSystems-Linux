1.2 Скриптове (теми 1,2,3,4,5)

Зад. 16 2016-SE-01 
Напишете shell скрипт, който по подаден един позиционен параметър, ако този
параметър е директория, намира всички symlink-ове в нея и под-директориите `и с несъществуващ
destination.


Зад. 17 2016-SE-02
Напишете shell скрипт, който приема един позиционен параметър - число. Ако
скриптът се изпълнява като root, да извежда обобщена информация за общото количество активна
памет (RSS - resident set size, non-swapped physical memory that a task has used) на процесите на
всеки потребител. Ако за някой потребител обобщеното число надвишава подадения параметър, да
изпраща подходящи сигнали за прекратяване на процеса с най-много активна памет на потребителя.
Забележка: Приемаме, че изхода в колоната RSS е число в същата мерна единица, като числото,
подадено като аргумент. 
Примерен формат:
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.0 15816 1884 ? Ss May12 0:03 init [2]
root 2 0.0 0.0 0 0 ? S May12 0:00 [kthreadd]
root 3 0.0 0.0 0 0 ? S May12 0:02 [ksoftirqd/0]
Забележка: Алтернативно може да ползвате изхода от ps -e -o uid,pid,rss

Зад. 18 2016-SE-03 
Напишете shell скрипт който, ако се изпълнява от root, проверява кои потребители
на системата нямат homedir или не могат да пишат в него.
Примерен формат:
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin

Зад. 19 2016-SE-03 
В текущата директория има само обикновени файлове (без директории). Да се
напише bash script, който приема 2 позиционни параметъра – числа, който мести файловете от
текущата директория към нови директории (a, b и c, които трябва да бъдат създадени), като
определен файл се мести към директория ’a’, само ако той има по-малко редове от първи позиционен
параметър, мести към директория ’b’, ако редове са между първи и втори позиционен параметър
и в ’c’ в останалите случаи.


Зад. 20 2016-SE-04 
Файловете във вашата home директория съдържат информация за музикални албуми и имат специфична структура. 
Началото на всеки ред е годината на издаване на албума, а
непосредствено, след началото на всеки ред следва името на изпълителя на песента. Имената на
файловете се състоят от една дума, която съвпада с името на изпълнителя.

Примерно съдържание на файл с име "Bonnie":
2005г. Bonnie - "God Was in the Water" (Randall Bramblett, Davis Causey) – 5:17
2005г. Bonnie - "Love on One Condition" (Jon Cleary) – 3:43
2005г. Bonnie - "So Close" (Tony Arata, George Marinelli, Pete Wasner) – 3:22
2005г. Bonnie - "Trinkets" (Emory Joseph) – 5:02
2005г. Bonnie - "Crooked Crown" (David Batteau, Maia Sharp) – 3:49
2005г. Bonnie - "Unnecessarily Mercenary" (Jon Cleary) – 3:51
2005г. Bonnie - "I Will Not Be Broken" - "Deep Water" (John Capek, Marc Jordan) – 3:58

Да се напише shell скрипт приемащ два параметъра, които са имена на файлове от вашата home директория. Скриптът сравнява, кой от двата файла има повече на брой редове, съдържащи неговото
име (на файла). За файлът победител изпълнете следните действия:
• извлечете съдържанието му, без годината на издаване на албума и без името на изпълнителя
• сортирайте лексикографски извлеченото съдържание и го запишете във файл с име ’изпълнител.songs’
Примерен изходен файл (с име Bonnie.songs):
"Crooked Crown" (David Batteau, Maia Sharp) – 3:49
"God Was in the Water" (Randall Bramblett, Davis Causey) – 5:17
"I Will Not Be Broken" - "Deep Water" (John Capek, Marc Jordan) – 3:58
"Love on One Condition" (Jon Cleary) – 3:43
"So Close" (Tony Arata, George Marinelli, Pete Wasner) – 3:22
"Trinkets" (Emory Joseph) – 5:02
"Unnecessarily Mercenary" (Jon Cleary) – 3:51

Зад. 21 2016-SE-06 
Имате текстов файл със следното съдържание (всяка книга е на един ред):
1979 г. - „Синият тайфун“ (сборник съветски научнофантастични разкази за морето)
1979 г. - „Двойната звезда“ - Любен Дилов
1979 г. - „Завръщане от звездите“ - Станислав Лем (Превод: Веселин Маринов)
1979 г. - „Среща с Рама“ - Артър Кларк (Превод: Александър Бояджиев)
1979 г. - „Алиби“ - Димитър Пеев (криминален роман)
1979 г. - „Тайнственият триъгълник“ (сборник НФ разкази за морето)
1979 г. - „Второто нашествие на марсианците“ - Аркадий и Борис Стругацки
1979 г. - „Гробищен свят“ - Клифърд Саймък (Превод: Михаил Грънчаров)
1979 г. - „Чоки“ - Джон Уиндъм (Превод: Теодора Давидова)
1979 г. - „Спускане в Маелстрьом“ - Едгар Алан По (Превод: Александър Бояджиев)
1980 г. - „Допълнителна примамка“ - Робърт Ф. Йънг (Превод: Искра Иванова, ...)
1980 г. - „Кристалното яйце“ - Хърбърт Уелс (Превод: Борис Миндов, ...)
1980 г. - „Онирофилм“ (сборник италиански НФ разкази) (Превод: Никола Иванов, ...)

Напишете shell script (приемащ аргумент име на файл) който извежда:
• всеки ред от файла с добавен пореден номер във формат "1. ", "2. ", ... "11. " ...
• махат данните за годината на издаване
• сортират изхода по заглавие (лексикографски, възходящо)

Примерен изход (показани са само първите 4 реда):
5. „Алиби“ - Димитър Пеев (криминален роман)
7. „Второто нашествие на марсианците“ - Аркадий и Борис Стругацки
8. „Гробищен свят“ - Клифърд Саймък (Превод: Михаил Грънчаров)
2. „Двойната звезда“ - Любен Дилов

Зад. 22 2017-IN-01 
Напишете скрипт, който приема три задължителни позицонни аргумента:
• име на фаил
• низ1
• низ2
Файлът е текстови, и съдържа редове във формат:
ключ=стойност
където стойност може да бъде:
• празен низ, т.е. редът е ключ=
• низ, състоящ се от един или повече термове, разделени с интервали, т.е., редът е ключ=t1 t2 t3
Някъде във файла:
• се съдържа един ред с ключ първия подаден низ (низ1 );
• и може да се съдържа един ред с ключ втория подаден низ (низ2 ).
Скриптът трябва да променя реда с ключ низ2 така, че обединението на термовете на редовете с
ключове низ1 и низ2 да включва всеки терм еднократно.
Примерен входен файл:
$ cat z1.txt
FOO=73
BAR=42
BAZ=
ENABLED_OPTIONS=a b c d
ENABLED_OPTIONS_EXTRA=c e f
Примерно извикване:
$ ./a.sh z1.txt ENABLED_OPTIONS ENABLED_OPTIONS_EXTRA
Изходен файл:
$ cat z1.txt
FOO=73
BAR=42
BAZ=
ENABLED_OPTIONS=a b c d
ENABLED_OPTIONS_EXTRA=e f
Зад. 23 2017-IN-02 Напишете скрипт, който приема задължителен позиционен аргумент - име на потребител FOO. Ако скриптът се изпълнява от root:
а) да извежда имената на потребителите, които имат повече на брой процеси от FOO, ако има
такива;
б) да извежда средното време (в секунди), за което са работили процесите на всички потребители
на системата (TIME, във формат HH:MM:SS);
в) ако съществуват процеси на FOO, които са работили над два пъти повече от средното време,
скриптът да прекратява изпълнението им по подходящ начин.
За справка:
7
$ ps -e -o user,pid,%cpu,%mem,vsz,rss,tty,stat,time,command | head -5
USER PID %CPU %MEM VSZ RSS TT STAT TIME COMMAND
root 1 0.0 0.0 15820 1920 ? Ss 00:00:05 init [2]
root 2 0.0 0.0 0 0 ? S 00:00:00 [kthreadd]
root 3 0.0 0.0 0 0 ? S 00:00:01 [ksoftirqd/0]
root 5 0.0 0.0 0 0 ? S< 00:00:00 [kworker/0:0H]
Зад. 24 2017-IN-03 Напишете скрипт, който извежда името на потребителския акаунт, в чиято home
директория има най-скоро променен обикновен файл и кой е този файл. Напишете скрипта с подходящите проверки, така че да бъде валиден инструмент.
Зад. 25 2017-SE-01 Напишете скрипт, който получава задължителен първи позиционен параметър – директория и незадължителен втори – число. Скриптът трябва да проверява подадената директория
и нейните под-директории и да извежда имената на:
а) при подаден на скрипта втори параметър – всички файлове с брой hardlink-ове поне равен на
параметъра;
б) при липса на втори параметър – всички symlink-ове с несъществуващ destination (счупени
symlink-ове).
Забележка:За удобство приемаме, че ако има подаден втори параметър, то той е число.
Зад. 26 2017-SE-02 Напишете скрипт, който приема три задължителни позиционни параметра - директория SRC, директория DST (която не трябва да съдържа файлове) и низ АBC. Ако скриптът се
изпълнява от root потребителя, то той трябва да намира всички файлове в директорията SRC и
нейните под-директории, които имат в името си като под-низ АBC, и да ги мести в директорията
DST, запазвайки директорийната структура (но без да запазва мета-данни като собственик и права,
т.е. не ни интересуват тези параметри на новите директории, които скриптът би генерирал в DST).
Пример:
• в SRC (/src) има следните файлове:
/src/foof.txt
/src/1/bar.txt
/src/1/foo.txt
/src/2/1/foobar.txt
/src/2/3/barf.txt
• DST (/dst) е празна директория
• зададения низ е foo
Резултат:
• в SRC има следните файлове:
/src/1/bar.txt
/src/2/3/barf.txt
• в DST има следните файлове:
/dst/foof.txt
/dst/1/foo.txt
/dst/2/1/foobar.txt
Зад. 27 2017-SE-03 Напишете скрипт, който ако се изпълнява от root потребителя:
а) извежда обобщена информация за броя и общото количество активна памет (RSS - resident set
size, non-swaped physical memory that a task has used) на текущите процеси на всеки потребител;
б) ако процесът с най-голяма активна памет на даден потребител използва два пъти повече памет
от средното за потребителя, то скриптът да прекратява изпълнението му по подходящ начин.
За справка:
$ ps aux | head -5
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.0 15820 1052 ? Ss Apr21 0:06 init [2]
8
root 2 0.0 0.0 0 0 ? S Apr21 0:00 [kthreadd]
root 3 0.0 0.0 0 0 ? S Apr21 0:02 [ksoftirqd/0]
root 5 0.0 0.0 0 0 ? S< Apr21 0:00 [kworker/0:0H]
Алтернативно, може да ползвате изхода от ps -e -o uid,pid,rss
Зад. 28 2017-SE-04 Напишете shell script, който получава задължителен първи позиционен параметър
– директория и незадължителен втори – име на файл. Скриптът трябва да намира в подадената
директория и нейните под-директории всички symlink-ове и да извежда (при подаден аргумент
файл – добавяйки към файла, а ако не е – на стандартния изход) за тях следната информация:
• ако destination-a съществува – името на symlink-а -> името на destination-а;
• броя на symlink-овете, чийто destination не съществува.
Примерен изход:
lbaz -> /foo/bar/baz
lqux -> ../../../qux
lquux -> /foo/quux
Broken symlinks: 34
Зад. 29 2017-SE-05 Напишете скрипт, който получава два задължителни позиционни параметъра –
директория и низ. Сред файловете в директорията би могло да има такива, чиито имена имат
структура vmlinuz-x.y.z-arch където:
• vmlinuz е константен низ;
• тиретата “-” и точките “.” присъстват задължително;
• x е число, version;
• y е число, major revision;
• z е число, minor revision;
• наредената тройка x.y.z формира глобалната версия на ядрото;
• arch е низ, архитектура (платформа) за която е съответното ядро.
Скриптът трябва да извежда само името на файла, намиращ се в подадената директория (но не и
нейните поддиректории), който:
• спазва гореописаната структура;
• е от съответната архитектура спрямо параметъра-низ, подаден на скрипта;
• има най-голяма глобална версия.
Пример:
• Съдържание на ./kern/:
vmlinuz-3.4.113-amd64
vmlinuz-4.11.12-amd64
vmlinuz-4.12.4-amd64
vmlinuz-4.19.1-i386
• Извикване и изход:
$ ./task1.sh ./kern/ amd64
vmlinuz-4.12.4-amd64
Зад. 30 2017-SE-06 Напишете скрипт, който ако се изпълнява от root потребителя, намира процесите
на потребителите, които не са root потребителя и е изпълнено поне едно от следните неща:
• имат зададена несъществуваща home директория;
• не са собственици на home директорията си;
• собственика на директорията не може да пише в нея.
Ако общото количество активна памет (RSS - resident set size, non-swaped physical memory that a task
has used) на процесите на даден такъв потребител е по-голямо от общото количество активна памет
на root потребителя, то скриптът да прекратява изпълнението на всички процеси на потребителя.
За справка:
$ ps aux | head -n 5
9
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.0 15820 1052 ? Ss Apr21 0:06 init [2]
root 2 0.0 0.0 0 0 ? S Apr21 0:00 [kthreadd]
root 3 0.0 0.0 0 0 ? S Apr21 0:02 [ksoftirqd/0]
root 5 0.0 0.0 0 0 ? S< Apr21 0:00 [kworker/0:0H]
Алтернативно, може да ползвате изхода от ps -e -o uid,pid,rss
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
s61934:x:1177:504:Mariq Cholakova:/home/SI/s61934:/bin/bash
Зад. 31 2018-SE-01 Нека съществува програма за моментна комуникация (Instant messaging), която
записва логове на разговорите в следния формат:
• има определена директория за логове (LOGDIR)
• в нея има директорийна структура от следния вид:
LOGDIR/протокол/акаунт/приятел/
като на всяко ниво може да има няколко екземпляра от съответния вид, т.е. няколко директории протокол, във всяка от тях може да има няколко директории акаунт, и във всяка от
тях – няколко директории приятел
• във всяка от директориите приятел може да има файлове с имена от вида yyyy-mm-dd-hh-mm-ss.txt
– година-месец-ден и т.н., спрямо това кога е започнал даден разговор
• всеки такъв файл представлява лог на даден разговор със съответния приятел, като всяка
разменена реплика между вас е на отделен ред
• даден идентификатор приятел може да се среща няколко пъти в структурата (напр. през
различни ваши акаунти сте водили разговори със същия приятел)
Напишете скрипт, който приема задължителен позиционен аргумент - име на лог директория
(LOGDIR). Скриптът трябва да извежда десетимата приятели, с които имате най-много редове
комуникация глобално (без значение протокол и акаунт), и колко реда имате с всеки от тях. Опишете в коментар как работи алгоритъмът ви.
Зад. 32 2018-SE-02 Напишете скрипт, който приема два позиционни аргумента – име на текстови файл
и директория. Директорията не трябва да съдържа обекти, а текстовият файл (US-ASCII) е стенограма и всеки ред е в следния формат:
ИМЕ ФАМИЛИЯ (уточнения): Реплика
където:
• ИМЕ ФАМИЛИЯ присъстват задължително;
• ИМЕ и ФАМИЛИЯ се състоят само от малки/главни латински букви и тирета;
• (уточнения) не е задължително да присъстват;
• двоеточието ‘:’ присъства задължително;
• Репликата не съдържа знаци за нов ред;
• в стринга преди двоеточието ‘:’ задължително има поне един интервал между ИМЕ и ФАМИЛИЯ;
• наличието на други интервали където и да е на реда е недефинирано.
Примерен входен файл:
John Lennon (The Beatles): Time you enjoy wasting, was not wasted.
Roger Waters: I’m in competition with myself and I’m losing.
John Lennon:Reality leaves a lot to the imagination.
Leonard Cohen:There is a crack in everything, that’s how the light gets in.
Скриптът трябва да:
• създава текстови файл dict.txt в посочената директория, който на всеки ред да съдържа:
ИМЕ ФАМИЛИЯ;НОМЕР
където:
10
– ИМЕ ФАМИЛИЯ е уникален участник в стенограмата (без да се отчитат уточненията);
– НОМЕР е уникален номер на този участник, избран от вас.
• създава файл НОМЕР.txt в посочената директория, който съдържа всички (и само) редовете
на дадения участник.

Зад. 33 2018-SE-03 Напишете скрипт, който приема два позиционни аргумента – имена на текстови
файлове в CSV формат:
8,foo,bar,baz
2,quz,,foo
12,1,3,foo
3,foo,,
5,,bar,
7,,,
4,foo,bar,baz
Валидни са следните условия:
• CSV файловете представляват таблица, като всеки ред на таблицата е записан на отделен ред;
• на даден ред всяко поле (колона) е разделено от останалите със запетая;
• броят на полетата на всеки ред е константа;
• в полетата не може да присъства запетая, т.е., запетаята винаги е разделител между полета;
• ако във файла присъстват интервали, то това са данни от дадено поле;
• първото поле на всеки ред е число, което представлява идентификатор на реда (ID).
Примерно извикване: ./foo.sh a.csv b.csv
Скриптът трябва да чете a.csv и на негова база да създава b.csv по следния начин:
• някои редове във файла се различават само по колоната ID, и за тях казваме, че формират
множество Ai
• за всяко такова множество Ai да се оставя само един ред - този, с най-малка стойност на ID-то;
• редовете, които не са членове в някое множество Ai се записват в изходния файл без промяна.

Зад. 34 2019-SE-01 Напишете два скрипта (по един за всяка подточка), които четат редове от STDIN.
Скриптовете трябва да обработват само редовете, които съдържат цели положителни или отрицателни числа; останалите редове се игнорират. Скриптовете трябва да извежда на STDOUT:
а) всички уникални числа, чиято абсолютна стойност е равна на максималната абсолютна стойност сред всички числа
б) всички най-малки уникални числа от тези, които имат максимална сума на цифрите си
Примерен вход:
We don’t
n11d n0
educat10n
12.3
6
33
-42
-42
111
111
-111
Примерен изход за а):
-111
111
Примерен изход за б):
-42
11
Зад. 35 2019-SE-02 Напишете шел скрипт, който приема множество параметри. Общ вид на извикване:
./foo.sh [-n N] FILE1...
В общия случай параметрите се третират като имена на (.log) файлове, които трябва да бъдат
обработени от скрипта, със следното изключение: ако първият параметър е стрингът -n, то вторият параметър е число, дефиниращо стойност на променливата N, която ще ползваме в скрипта.
Въвеждаме понятието идентификатор на файл (ИДФ), което се състои от името на даден файл
без разширението .log. За удобство приемаме, че скриптът:
• ще бъде извикван с аргументи имена на файлове, винаги завършващи на .log
• няма да бъде извикван с аргументи имена на файлове с еднакъв ИДФ.
Лог файловете са текстови, като всеки ред има следния формат:
• време: timestamp във формат YYYY-MM-DD HH:MM:SS
• интервал
• данни: поредица от символи с произволна дължина
За удобство приемаме, че редовете във всеки файл са сортирани по време възходящо.
Примерно съдържание на даден лог файл:
2019-05-05 06:26:54 orthanc rsyslogd: rsyslogd was HUPed
2019-05-06 06:30:32 orthanc rsyslogd: rsyslogd was HUPed
2019-05-06 10:48:29 orthanc kernel: [1725379.728871] Chrome_~dThread[876]: segfault
Скриптът трябва да извежда на STDOUT последните N реда (ако N не е дефинирано - 10 реда) от
всеки файл, в следния формат:
• timestamp във формат YYYY-MM-DD HH:MM:SS
• интервал
• ИДФ
• интервал
• данни
Изходът трябва да бъде глобално сортиран по време възходящо.
Зад. 36 2019-SE-03 За удобство приемаме, че разполагате със системен инструмент sha256sum, който
приема аргументи имена на файлове като за всеки файл пресмята и извежда уникална хеш стойност,
базирана на съдържанието на файла. Изходът от инструмента е текстови, по един ред за всеки
подаден като аргумент файл, в следния формат:
• хеш стойност с дължина точно 64 знака
• два интервала
• име на файл
Примерна употреба и изход:
$ sha256sum /var/log/syslog /var/log/user.log README.md
b2ff8bd882a501f71a144b7c678e3a6bc6764ac48eb1876fb5d11aac11014b78 /var/log/syslog
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 /var/log/user.log
e4702d8044b7020af5129fc69d77115fd4306715bd678ba4bef518b2edf01fb9 README.md
Напишете скрипт, който приема задължителен параметър име на директория (ДИР1). Някъде в
директорията ДИР1 може да съществуват архивни файлове с имена NAME_report-TIMESTAMP.tgz,
където:
• NAME е низ, който не съдържа символ ’_’
• TIMESTAMP е във формат Unix time (POSIX time/UNIX Epoch time)
На всяко пускане на скрипта се обработват само новосъздадените или модифицираните по съдържание спрямо предното пускане на скрипта архивни файлове от горния тип. За всеки такъв архивен
файл се изпълнява следното:
• ако архивният файл съдържа файл с име meow.txt, то този текстови файл да бъде записан под
името /extracted/NAME_TIMESTAMP.txt, където NAME и TIMESTAMP са съответните стойности
от името на архивния файл.
12
Зад. 37 2020-SE-01 Напишете shell скрипт, който получава два задължителни позиционни параметъра
- име на файл (bar.csv) и име на директория. Директорията може да съдържа текстови файлове
с имена от вида foobar.log, всеки от които има съдържание от следния вид:
Пример 1 (loz-gw.log):
Licensed features for this platform:
Maximum Physical Interfaces : 8
VLANs : 20
Inside Hosts : Unlimited
Failover : Active/Standby
VPN-3DES-AES : Enabled
*Total VPN Peers : 25
VLAN Trunk Ports : 8
This platform has an ASA 5505 Security Plus license.
Serial Number: JMX00000000
Running Activation Key: 0e268e0c
Пример 2 (border-lozenets.log):
Licensed features for this platform:
Maximum Physical Interfaces : 4
VLANs : 16
Inside Hosts : Unlimited
Failover : Active/Active
VPN-3DES-AES : Disabled
*Total VPN Peers : 16
VLAN Trunk Ports : 4
This platform has a PIX 535 license.
Serial Number: PIX5350007
Running Activation Key: 0xd11b3d48
Имената на лог файловете (loz-gw, border-lozenets) определят даден hostname, а съдържанието
им дава детайли за определени параметри на съответният хост.
Файлът bar.csv, който трябва да се генерира от вашия скрипт, е т.н. CSV (comma separated values)
файл, тоест текстови файл - таблица, на който полетата на всеки ред са разделени със запетая.
Първият ред се ползва за определяне на имената на колоните.
Скриптът трябва да създава файла bar.csv на база на log файловете в директорията. Генерираният
CSV файл от директория, която съдържа само loz-gw.log и border-lozenets.log би изглеждал
така:
hostname,phy,vlans,hosts,failover,VPN-3DES-AES,peers,VLAN Trunk Ports,license,SN,key
loz-gw,8,20,Unlimited,Active/Standby,Enabled,25,8,ASA 5505 Security Plus,JMX00000000,0e268e0c
border-lozenets,4,16,Unlimited,Active/Active,Disabled,16,4,PIX 535,PIX5350007,0xd11b3d48
Полетата в генерирания от скрипта CSV файл не трябва да съдържат излишни trailing/leading
интервали. За улеснение, приемете, че всички whitespace символи във входните файлове са символа
“интервал”.
Зад. 38 2020-SE-02 Напишете shell скрипт, който приема задължителен параметър - име на файл.
Файлът е log файл на HTTP сървър, в който се записват всички получени от сървъра request-и,
13
които клиентите са изпратили. Файлът е текстови, като на всеки ред има информация от следния
вид:
35.223.122.181 dir.bg - [03/Apr/2020:17:25:06 -0500] GET / HTTP/1.1 302 0 "-" "Zend_Http_Client"
94.228.82.170 del.bg - [03/Apr/2020:17:25:06 -0500] POST /auth HTTP/2.0 400 153 "foo bar" "<UA>"
Всеки ред на файла се състои от полета, разделени с интервал. Описание на полетата с пример
спрямо първият ред от горните:
• адрес на клиент - 35.223.122.181
• име на виртуален хост (сайт) - dir.bg
• име на потребител - -
• timestamp на заявката - [03/Apr/2020:17:25:06 -0500]
• заявка - GET / HTTP/1.1 - състои се от три компонента, разделени с интервал: метод на заявката (за удобство приемаме, че може да има само GET и POST заявки), ресурсен идентификатор,
и протокол (приемаме, че може да има само HTTP/1.0, HTTP/1.1 и HTTP/2.0 протоколи)
• код за статус на заявката - 302
• брой байтове - 0
• referer - "-" - ограден в двойни кавички, подава се от HTTP клиента, произволен низ
• user agent - "Zend_Http_Client" - ограден в двойни кавички, подава се от HTTP клиента,
произволен низ
За всеки от top 3 сайта, към които има най-много заявки, скриптът трябва да изведе в долния
формат:
• брой на HTTP/2.0 заявките
• брой на не-HTTP/2.0 заявките
• top 5 клиента, направили най-много заявки, завършили с код, по-голям от 302 (и броя на
съответните им зявки)
dir.bg HTTP/2.0: 0 non-HTTP/2.0: 5
del.bg HTTP/2.0: 5 non-HTTP/2.0: 0
5 94.228.82.170
2 34.73.112.204
1 185.217.0.138
Зад. 39 2020-SE-03 Под пакет ще разбираме директория, която има следната структура:
<name>
|-- version
|-- tree
|...
Където <name> е името на пакета, version е текстов файл, който съдържа низ от вида 1.2.3-4 и
нищо друго, а tree е директория с произволно съдържание.
За да получим архив на пакет, архивираме (tar) и компресираме (xz) съдържанието на директорията tree.
Под хранилище ще разбираме директория, която има следната структура:
<repo name>
|-- db
|-- packages
|...
Където <repo name> е името на хранилището, db е текстов файл, чиито редове имат вида <package
name>-<package version> <package checksum> и са сортирани лексикографски. Директорията packages
съдържа архиви с имена <package checksum>.tar.xz, които съответстват на редове в db. Под
<package checksum> имаме предвид sha256 сумата на архива на пакета.
14
Напишете скрипт repo_add.sh, който приема два аргумента - път до хранилище и път до пакет,
който добавя пакета в хранилището. Ако същата версия на пакет вече съществува, архивът се
заменя с новата версия. В противен случай, новата версия се добавя заедно с другите.
Заб: Първо си проектирайте общия алгоритъм на работа.
Примерно хранилище:
myrepo
|-- db
|-- packages
|-- 6e3549438bc246b86961b2e8c3469321ca22eabd0a6c487d086de7a43a0ef766.tar.xz
|-- 66b28e48161ba01ae25433b9ac4086a83b14d2ee49a62f2659c96514680ab6e8.tar.xz
|-- 99c934ad80bd9e49125523c414161e82716b292d4ed2f16bb977d6db7e13d9bc.tar.xz
Със съдържание на db:
glibc-2.31-2 6e3549438bc246b86961b2e8c3469321ca22eabd0a6c487d086de7a43a0ef766
zlib-1.1.15-8 66b28e48161ba01ae25433b9ac4086a83b14d2ee49a62f2659c96514680ab6e8
zlib-1.2.11-4 99c934ad80bd9e49125523c414161e82716b292d4ed2f16bb977d6db7e13d9bc
Примерен пакет:
zlib
|-- version # contains ’1.2.11-3’
|-- tree
|...
Съдържание на хранилището след изпълнение на ./repo-add.sh myrepo zlib
myrepo
|-- db
|-- packages
|-- 6e3549438bc246b86961b2e8c3469321ca22eabd0a6c487d086de7a43a0ef766.tar.xz
|-- 66b28e48161ba01ae25433b9ac4086a83b14d2ee49a62f2659c96514680ab6e8.tar.xz
|-- b839547ee0aed82c74a37d4129382f1bd6fde85f97c07c5b705eeb6c6d69f162.tar.xz
|-- 99c934ad80bd9e49125523c414161e82716b292d4ed2f16bb977d6db7e13d9bc.tar.xz
Със съдържание на db:
glibc-2.31-2 6e3549438bc246b86961b2e8c3469321ca22eabd0a6c487d086de7a43a0ef766
zlib-1.1.15-8 66b28e48161ba01ae25433b9ac4086a83b14d2ee49a62f2659c96514680ab6e8
zlib-1.2.11-3 b839547ee0aed82c74a37d4129382f1bd6fde85f97c07c5b705eeb6c6d69f162
zlib-1.2.11-4 99c934ad80bd9e49125523c414161e82716b292d4ed2f16bb977d6db7e13d9bc

Зад. 40 2020-SE-04 Напишете скрипт, който приема два аргумента - имена на директории. Първата
(SRC ) съществува, докато втората (DST) трябва да бъде създадена от скрипта. Директорията SRC
и нейните поддиректории може да съдържат файлове, чиито имена завършат на .jpg. Имената на
файловете може да съдържат интервали, както и поднизове, оградени със скоби, например:
A single (very ugly) tree (Outdoor treks) 2.jpg
Falcons.jpg
Gorgonzola (cheese).jpg
Leeches (two different ones) (Outdoor treks).jpg
Pom Pom Pom.jpg
За даден низ ще казваме, че е почистен, ако от него са премахнати leading и trailing интервалите
и всички последователни интервали са сведени до един.
За всеки файл дефинираме следните атрибути:
15
• заглавие - частта от името преди .jpg, без елементи оградени в скоби, почистен. Примери:
A single tree 2
Falcons
Gorgonzola
Leeches
Pom Pom Pom
• албум - последният елемент от името, който е бил ограден в скоби, почистен. Ако албум е
празен стринг, ползваме стойност по подразбиране misc. Примери:
Outdoor treks
misc
cheese
Outdoor treks
misc
• дата - времето на последна модификация на съдържанието на файла, във формат YYYYMM-DD
• хеш - първите 16 символа от sha256 сумата на файла. Забележка: приемаме, че в тази идеална
вселена първите 16 символа от sha256 сумата са уникални за всеки файл от тези, които
ще се наложи да обработваме.
Скриптът трябва да създава в директория DST необходимата структура от под-директории, файлове и symlink–ове, така че да са изпълнени следните условия за всеки файл от SRC :
• DST/images/хеш.jpg - копие на съответния файл
• следните обекти са относителни symlink–ове към хеш.jpg:
– DST/by-date/дата/by-album/албум/by-title/заглавие.jpg
– DST/by-date/дата/by-title/заглавие.jpg
– DST/by-album/албум/by-date/дата/by-title/заглавие.jpg
– DST/by-album/албум/by-title/заглавие.jpg
– DST/by-title/заглавие.jpg
Зад. 41 2020-SE-05 Напишете shell скрипт, който приема 3 позиционни аргумента – две имена на файлове
и име на директория. Примерно извикване:
$ ./foo.sh foo.pwd config.cfg cfgdir/
В директорията cfgdir/ и нейните под-директории може да има файлове с имена завършващи
на .cfg. За да са валидни, тези файлове трябва да съдържат редове само в следните формати
(редовете започващи с # са коментари):
# internal laboratory
{ no-production };
{ volatile };
# meow configs
{ run-all; };
Във файла foo.pwd има описани потребителски имена (username) и MD5 хеш суми на паролите им,
с по един запис на ред, в следният формат:
username:password_hash
Също така, разполагате с команда pwgen, която генерира и извежда на STDOUT случайни пароли, и
знаете, че поддържа следните два аргумента:
$ pwgen [ password_length ] [ number_of_passwords ]
16
Вашият скрипт трябва да валидира cfg файловете в директорията, и за тези, които не са валидни, да
извежда на STDOUT името на файла и номерирани редовете, които имат проблем, в следния формат:
Error in filename.cfg:
Line 1:XXXX
Line 37:YYYY
където XXXX и YYYY е съдържанието на съответния ред.
За валидните файлове, скриптът трябва да:
• генерира config.cfg като обединение на съдържанието им;
• името на файла, без частта .cfg дефинира потребителско име. Ако във файла с паролите не
съществува запис за този потребител, то такъв да се добави и на стандартния изход да се
изведе потребителското име и паролата (поне 16 символа) разделени с един интервал.
Зад. 42 2020-SE-06 Под конфигурационен файл ще разбираме файл, в който има редове от вида key=value,
където key и value могат да се състоят от букви, цифри и знак “долна черта” (“_”). Освен това,
във файла може да има празни редове; може да има произволен whitespace в началото и в края на
редовете, както и около символа “=”. Също така са допустими и коментари в даден ред: всичко след
символ “#” се приема за коментар.
Под <date> ще разбираме текущото време, върнато от командата date без параметри; под <user>
ще разбираме името на текущият потребител.
Напишете shell скрипт set_value.sh, който приема 3 позиционни аргумента – име на конфигурационен файл, ключ (foo) и стойност (bar). Ако ключът:
• присъства във файла с друга стойност, скриптът трябва да:
– да закоментира този ред като сложи # в началото на реда и добави в края на реда #
edited at <date> by <user>
– да добави нов ред foo = bar # added at <date> by <user> точно след стария ред
• не присъства във файла, скриптът трябва да добави ред от вида foo = bar # added at
<date> by <user> на края на файла
Примерен foo.conf:
# route description
from = Sofia
to = Varna # my favourite city!
type = t2_1
Примерно извикване:
./set_value.sh foo.conf to Plovdiv
Съдържание на foo.conf след извикването:
# route description
from = Sofia
# to = Varna # my favourite city! # edited at Tue Aug 25 15:48:29 EEST 2020 by human
to = Plovdiv # added at Tue Aug 25 15:48:29 EEST 2020 by human
type = t2_1
Зад. 43 2021-SE-01
Разполагате с машина, на която е инсталиран специализиран софтуер, който ползва два потребителски акаунта – oracle и grid. Всеки от потребителите би трябвало да има environment променлива ORACLE_HOME, която указва абсолютен път до директория във формат /path/to/dir. В поддиректория bin на зададената директория би трябвало да има изпълним файл с име adrci. Всеки от
двата потребителя има собствена директория diag_dest, която е във вида /u01/app/потребител. Когато някой от потребителите изпълни неговото копие на командата adrci с параметър exec="show
homes" може да получи на STDOUT един от следните два изхода:
17
• вариант 1: (неуспех): No ADR homes are set
• вариант 2: (успех):
ADR Homes:
diag/rdbms/orclbi/orclbi1
diag/rdbms/orclbi/orclbi2
И в двата случая командата приключва с exit code 0. Ако командата се изпълни успешно, тя връща
списък с един или повече ADR Homes, които са релативни имена на директории спрямо diag_dest
на съответният потребител.
Напишете скрипт, който може да се изпълнява само от някой от тези два акаунта, и извежда на
STDOUT размера в мегабайти и абсолютният път на всеки ADR Home.
Примерен изход:
0 /u01/app/oracle/diag/rdbms/orclbi/orclbi1
389 /u01/app/oracle/diag/rdbms/orclbi/orclbi2
Зад. 44 2021-SE-02
Един от често използваните DNS сървъри е BIND9, при който описанието на DNS зоните обикновенно стои в текстови файлове, наричани зонални файлове. За улеснение, в рамките на задачата,
ще ползваме опростено описание на зоналните файлове.
Под whitespace разбираме произволна комбинация от табове и интервали.
Под FQDN разбираме низ, който има допустими символи малки латински букви, цифри и точка; не
може да започва с точка, не може да има две или повече съседни точки, задължително завършва
с точка.
Зоналните файлове съдържат ресурсни записи, по един на ред. Общият вид на даден ресурсен запис
e <ключ> <TTL> <клас> <тип> <RDATA>, разделени с whitespace, например:
astero.openfmi.net. 3600 IN A 185.117.82.99
Където:
• ключ (astero.openfmi.net.) – FQDN
• TTL (3600) – цифри; полето може да липсва
• клас (IN) - главни латински букви; класът винаги е IN
• тип (A) - главни латински букви; някое от SOA, NS, A, AAAA
• RDATA (185.117.82.99) - данни на записа; различни за различните типове ресурсни записи;
всичко след типа до края на реда.
Знакът точка-и-запетая ; е знак за коментар, и всичко след него до края на реда се игнорира.
Във всеки зонален файл трябва да има точно един SOA запис, и той трябва да е първият запис във
файла. Пример за едноредов SOA запис:
openfmi.net. 3600 IN SOA nimbus.fccf.net. root.fccf.net. 2021041901 86400 7200 3024000 3600
RDATA-та на SOA запис се състои от два FQDN-а и пет числа, разделени с whitespace.
Въпреки, че горното е валиден SOA запис, за прегледност в зоналните файлове често се ползва
следният синтаксис (многоредов SOA запис, еквивалентен на горния):
openfmi.net. 3600 IN SOA nimbus.fccf.net. root.fccf.net. (
2021041901 ; serial
86400 ; refresh
7200 ; retry
3024000 ; expire
3600 ; negative TTL
)
18
т.е., поредицата от числа се разбива на няколко реда, оградени в обикновенни скоби, и за всяко
число се слага коментар какво означава.
Първото от тези числа (serial) представлява серийният номер на зоната, който трябва да се увеличава всеки път, когато нещо в зоналният файл се промени. Изключително важно е това число само
да нараства, и никога да не намалява.
Един от често използваните формати за сериен номер, който показва кога е настъпила последната
промяна в зоналния файл представлява число във вида YYYYMMDDTT, т.е., четири цифри за
година, две цифри за месец, две цифри за дата и още две цифри за поредна промяна в рамките на
описания ден. За последните две цифри (ТТ) има ограничение да са от 00 до 99 (естествено, така
не може да има повече от 100 промени в рамките на един ден).
За удобство приемаме, че конкретен сериен номер (точната поредица цифри) се среща само на едно
място в зоналния файл.
Напишете шел скрипт, който по подадени имена на зонални файлове променя серийният номер в
SOA записа на всеки файл по следният алгоритъм:
• ако датата в серийният номер е по-стара от днешната, новият сериен номер трябва да е от
вида днешнадата00
• ако датата в серийният номер е равна на днешната, серийният номер трябва да се увеличи с
единица
Важат следните условия:
• скриптът трябва да може да обработва и едноредови, и многоредови SOA записи
• за всеки зонален файл, който не е успял да обработи, скриптът трябва да вади съобщение за
грешка, което включва и името на зоналния файл. Съобщенията трябва да са лесно обработваеми с познатите инструменти за обработка на текст.
Зад. 45 2021-SE-03 Напишете shell скрипт, който приема два позиционни параметъра – имена на файлове. Примерно извикване:
$ ./foo.sh input.bin output.h
Файлът input.bin е двоичен файл с елементи uint16_t числа, създаден на little-endian машина.
Вашият скрипт трябва да генерира C хедър файл, дефиниращ масив с име arr, който:
• съдържа всички елементи от входния файл;
• няма указана големина;
• не позволява промяна на данните.
Генерираният хедър файл трябва да:
• съдържа и uint32_t променлива arrN, която указва големината на масива;
• бъде валиден и да може да се #include-ва без проблеми от C файлове, очакващи да “виждат”
arr и arrN.
За да е валиден един входен файл, той трябва да съдържа не повече от 524288 елемента.
За справка, dump на съдържанието на примерен input.bin:
00000000: 5555 5655 5955 5a55 6555 6655 6955 6a55 UUVUYUZUeUfUiUjU
00000010: 9555 9655 9955 9a55 a555 a655 a955 aa55 .U.U.U.U.U.U.U.U
Зад. 46 2021-SE-04
Разполагате с машина, на която е инсталиран специализиран софтуер, който ползва два потребителски акаунта – oracle и grid. За всеки от двата акаунта съществува директория, която ще
наричаме diag_dest и тя е от вида /u01/app/потребител.
Всеки от потребителите би трябвало да има environment променлива ORACLE_HOME, която указва
абсолютен път до директория във формат /път/до/дир. В поддиректорията bin на зададената
директория би трябвало да има изпълним файл с име adrci.
Всеки от потребителите може да подаде серия от подкоманди, които неговото копие на adrci да
изпълни, като го извика с параметър exec="cmd1; cmd2; cmd3". Отделните подкоманди се разделят
с точка и запетая (;). Командата adrci винаги приключва с exit code 0.
19
Нека дефинираме следните подкоманди:
• SET BASE – за да се гарантира правилна работа на командата adrci, при всяко нейно извикване първата подкоманда трябва да бъде от вида SET BASE diag_dest, където diag_dest е
абсолютният път на съответната директория за дадения потребител
• SHOW HOMES – подкоманда SHOW HOMES извежда на STDOUT един от следните два изхода:
– вариант 1: (неуспех): No ADR homes are set
– вариант 2: (успех):
ADR Homes:
diag/rdbms/orclbi/orclbi1
diag/rdbms/orclbi/orclbi2
Ако командата се изпълни успешно, тя връща списък с един или повече ADR Homes, които
са релативни имена на директории спрямо diag_dest на съответният потребител.
От полученият списък с релативни пътища интересни за нас са само тези, които за име на
директория на второ ниво имат една от следните директории: crs, tnslsnr, kfod, asm или
rdbms.
• SET HOMEPATH – подкоманда SET HOMEPATH път задава активна работна директория, спрямо
която ще се изпълняват последващи подкоманди в рамките на същото изпълнение на adrci;
път е релативен път до директория, спрямо изхода на SHOW HOMES
• PURGE – подкоманда PURGE -AGE минути изтрива определени файлове в текущо активната работна директория, по-стари от дефинираното време в минути. Забележка: изтриват се само
безопасни файлове, т.е. такива, чието изтриване няма да доведе до проблем. Дефиницията
на безопасни файлове е извън обхвата на тази задача.
Напишете shell скрипт, който може да се изпълнява само от някой от указаните два акаунта и
приема задължителен първи позиционен аргумент число (в часове, минимална стойност 2 часа).
Скриптът трябва да почиства безопасните файлове по-стари от зададените часове в интересните
ADR Home-ове на съответния потребител.
Зад. 47 2022-CE-01
Описание на формат на CSV (текстови) файл:
• CSV файлът представлява таблица, като всеки ред на таблицата е записан на отделен ред;
• на даден ред всяко поле (колона) е разделено от останалите със запетая;
• в полетата не може да присъства запетая, т.е. запетаята винаги е разделител между полета;
• броят на полетата на всеки ред е константа;
• първият ред във файла e header, който описва имената на колоните.
Разполагате с два CSV файла със следното примерно съдържание:
• base.csv:
unit name,unit symbol,measure
second,s,time
metre,m,length
kilogram,kg,mass
ampere,A,electric current
kelvin,K,thermodynamic temperature
mole,mol,amount of substance
candela,cd,luminous intensity
• prefix.csv:
prefix name,prefix symbol,decimal
tera,T,1000000000000
giga,G,1000000000
mega,M,1000000
mili,m,0.001
nano,n,0.000000001
Където смисълът на колоните е:
• за base.csv
– unit name – име на мерна единица
20
– unit symbol – съкратено означение на мерната единица
– measure – величина
• за prefix.csv
– prefix name – име на представка
– prefix symbol – означение на представка
– decimal – стойност
Забележка: Във файловете може да има и други редове, освен показаните в примера. Приемаме,
че файловете спазват описания по-горе формат, т.е. не е необходимо да проверявате формата.
Напишете shell скрипт, който приема три задължителни параметъра: число, prefix symbol и unit
symbol.
Скриптът, ако може, трябва да извежда числото в основната мерна единица без представка, добавяйки в скоби величината и името на мерната единица.
Примерен вход и изход:
$ ./foo.sh 2.1 M s
2100000.0 s (time, second)
Забележка: За изчисления може да ползвате bc.
Зад. 48 2022-CE-02 Съвременните компютри могат да влизат в различни режими за енергоспестяване
(suspend) и излизат от този режим (wake-up) при настъпването на определени събития. Linux kernel
предоставя специален виртуален файл /proc/acpi/wakeup, чрез който може да се проверява или
променя настройката за “събуждане” при при настъпване на различни събития. Тъй като този файл
е интерфейс към ядрото, “четенето” от файла и “писането” във файла изглеждат различно.
За улеснение на задачата ще ползваме опростено описание на този файл.
Под whitespace разбираме произволна комбинация от табове и интервали.
При четене от файла изходът представлява четири колони, разделени с whitespace, в полетата не
може да има whitespace; първият ред е header на съответната колона.
Примерно съдържание на файла:
Device S-state Status Sysfs node
GLAN S4 *enabled pci:0000:00:1f.6
XHC S3 *enabled pci:0000:00:14.0
XDCI S4 *disabled
LID S4 *enabled platform:PNP0C0D:00
HDAS S4 *disabled pci:0000:00:1f.3
RP01 S4 *enabled pci:0000:00:1c.0
където:
• първата колона дава уникално име на устройство, което може да събуди машината, като името
е ограничено до четири знака главни латински букви и цифри;
• третата колона описва дали това устройство може да събуди машината. Възможните стойности
са enabled/disabled, предхождани от звездичка;
• втората и четвъртата колона ги игнорираме в рамките на задачата.
При записване на име на устройство във файла /proc/acpi/wakeup, неговото състояние се променя
от disabled на enabled или обратно.
Например, ако /proc/acpi/wakeup изглежда както примера по-горе, при изпълнение на командата
echo XHC > /proc/acpi/wakeup, третият ред ще се промени на:
XHC S3 *disabled pci:0000:00:14.0
При изпълнение на командата echo HDAS > /proc/acpi/wakeup, шестият ред ще се промени на:
HDAS S4 *enabled pci:0000:00:1f.3
Напишете shell скрипт, който при подаден първи параметър име на устройство (напр. LID) настройва
съответното устройство да не може да събуди машината.

Зад. 49 2022-IN-01
Както знаете, при отваряне на файл с редактора vi, той създава в същата директория временен
файл с име в следния формат: точка, името на оригиналния файл, точка, swp. Например, при
редактиране на файл с име foo.txt ще се създаде временен файл с име .foo.txt.swp.
Напишете shell скрипт, който приема два задължителни позиционни аргумента – имена на директории. Примерно извикване: ./foo.sh ./dir1 /path/to/dir2/
В dir1 може да има файлове/директории, директорията dir2 трябва да е празна.
Скриптът трябва да копира всички обикновенни файлове от dir1 (и нейните под-директории) в
dir2, запазвайки директорийната структура, но без да копира временните файлове, създадени от
редактора vi (по горната дефиниция).
Забележка: За удобство приемаме, че не ни вълнува дали метаданните на обектите (owner, group,
permissions, etc.) ще се запазят.
Примерни обекти:
dir1/
dir1/a
dir1/.a.swp
dir1/b
dir1/c/d
dir1/c/.bar.swp
Обекти след изпълнението:
dir2/
dir2/a
dir2/b
dir2/c/d
dir2/c/.bar.swp
Зад. 50 2022-IN-02
Името на дадена машина можете да вземете с командата hostname -s.
Разполагате с машина, на която е инсталиран специализиран софтуер, който ползва два потребителски акаунта – oracle и grid.
Всеки от потребителите би трябвало да има environment променлива ORACLE_BASE, която указва
абсолютен път до директория във формат /път/до/дир.
Всеки от потребителите би трябвало да има environment променлива ORACLE_HOME, която указва
абсолютен път до директория във формат /път/до/дир. В поддиректорията bin на зададената
директория би трябвало да има изпълним файл с име sqlplus.
Всеки от потребителите би трябвало да има environment променлива ORACLE_SID с някакъв низ
като стойност.
Ако горните три environment променливи съществуват, всеки от потребителите може да изпълнява
неговото копие на командата sqlplus със следните параметри: sqlplus -SL "/ as роля" @foo.sql
където роля трябва да бъде низът SYSDBA при изпълнение от oracle и SYSASM при изпълнение от
grid. И в двата случая sqlplus изпълнява SQL заявките от файла (foo.sql, името на файла няма
значение) и извежда изхода на stdout. Ако съдържанието на sql файла е:
SELECT value FROM v$parameter WHERE name = ’diagnostic_dest’;
EXIT;
изходът ще бъде стойността на търсения параметър diagnostic_dest в следния вид:
oracle@astero:~$ sqlplus -SL "/ as sysdba" @a.sql
22
VALUE
--------------------------------------------------------------------------------
/u01/app/oracle
oracle@astero:~$
Параметърът diagnostic_dest може да няма стойност, в който случай изведеният низ ще е празен.
Изходът винаги е 5 реда, стойността винаги е на 4-и ред. Ако командата sqlplus не се изпълни
успешно, тя ще върне ненулев exit code.
За всеки от двата акаунта съществува директория, която ще наричаме diag_base. Конкретната
директория е:
• същата като ORACLE_BASE, ако diagnostic_dest няма стойност
• същата като diagnostic_dest, ако diagnostic_dest има стойност
За всеки от двата акаунта би трябвало да съществува под-директория на diag_base с име diag,
която ще наричаме diag_dir.
Съществуват три множества интересни за нас файлове:
• множество crs – за потребител grid, в diag_dir има под-директория crs, в която има поддиректория с името на машината, в която има под-директория crs, в която има под-директория
trace. Интересни за нас файлове в тази директория са такива, чието име завършва на
подчертавка-число и имат разширение trc или trm, например foo_356.trc, bar_40001.trm.
• множество tnslsnr – за потребител grid, в diag_dir има под-директория tnslsnr, в която има
под-директория с името на машината, в която има няколко директории с различни имена. Във
всяка от тези директории има под-директории alert и trace. Интересни за нас са файловете
в alert, чието име завършва на подчертавка-число и имат разширение xml (напр. baz_78.xml)
и файловете в trace, чието име завършва на подчертавка-число и имат разширение log (напр.
qux_88231.log).
• множество rdbms – за потребител oracle, в diag_dir има под-директория rdbms, в която има
няколко под-директории, във всяка от които може да има няколко под-директории. Интересни за нас са само файловете в тези директории на второ ниво, чието име завършва на
подчертавка-число и имат разширение trc или trm, например corge_27.trc, grault_1024.trm.
Напишете скрипт, който може да се изпълнява само от някой от тези два акаунта, и приема задължителен първи позиционен аргумент число (в дни). В зависимост от това кой потребител изпълнява
скрипта, той трябва да извежда на stdout за всяко множество на съответния потребител общият
размер (в килобайти) на описаните по-горе интересни файлове за които времето на последната
промяна (по съдържание) на файла е по-голямо от зададеното като параметър на скрипта.
Примерно изпълнение и изход:
oracle@astero:~$ ./foo.sh 42
rdbms: 14400
grid@astero:~$ ./foo.sh 73
crs: 28800
tnslsnr: 33600
Забележка: Правилното ползване на временни файлове е разрешено.
Зад. 51 2022-IN-03 Вашите колеги от съседната лаборатория работят по проект, в който до сега се е
ползвала нестандартна имплементация на командата java. По време на миграцията с цел използване на стандартна имплементация на командата се оказало, че на много места командата се
вика по стария, грешен начин, който вече е невалиден. Вашата задача е да напишете shell скрипт
iwojima.sh, който работи подобно на старата имплементация на java, но вътрешно вика новата
имплементация по правилния начин.
Файловият формат JAR (Java ARchive) представлява пакет, който обединява няколко Java class
файлове, допълнителни мета-данни и различни ресурси. Файлове в този формат обикновенно (но
не задължително) имат разширение .jar. Част от метаданните във файла указват кой е главният
23
клас, чийто метод main() се изпълнява по подразбиране. Въпросният main() метод ще получи списък
с аргументите, указани при извикването на командата java (подобно на main() функцията в езика
C).
Едно от извикванията на стандартната имплементация на командата java (единственото, което разглеждаме в тази задача) има следният синтаксис: java [options] -jar filename [args]
където:
• options – незадължителна поредица от опции на командата java, разделени с интервал; всяка
опция задължително започва с тире;
• filename – име на JAR файл, който да бъде изпълнен, използва се винаги с опция -jar;
• args – незадължителни аргументи, с които ще бъде стартиран main() методът на класа по
подразбиране (аргументи на самата Java програма).
Като пример разполагаме с JAR файл (app.jar), с един клас в него, чийто main() метод реализира
единствено функционалност, еквивалента на следният bash код:
if [ -z "${qux}" ]; then
qux=default
fi
echo "${qux}"
Общият вид на изпълнение с командата java би бил:
$ java -jar ./app.jar
default
Една от стандартните опции на командата java е -Dproperty=value, с което се дефинира променлива с име property и със стойност value. При нужда от няколко променливи, за всяка се ползва
отделна опция -D. Пример за правилно ползване на опцията в стандартната имплементация:
$ java -Dqux=foo -jar /path/to/app.jar
foo
За съжаление, нестандартната имплементация на java, която е ползвана до момента, работи по
друг начин. Пример:
$ java -jar ./app.jar -Dqux=foo
default
$ java -Dqux=foo -jar ./app.jar -hoge fuga
default
$ java -jar -Dqux=foo app.jar
foo
Ако трябва да обобщим как работи нестандартната имплементация:
• всичко след името на JAR файла са аргументи за main() метода (напр. -hoge и fuga);
• името на JAR файла е някъде след опцията -jar;
• опции за java командата може да има и преди, и след опцията -jar;
• опцията -Dproperty=value работи само ако е след опцията -jar.
Забележки: Вашият скрипт iwojima.sh няма нужда да поддържа извиквания, които не подават
опция -jar. За удобство приемаме, че опциите (вкл. property и value), имената на JAR файловете
и аргументите не могат да съдържат интервали.
Зад. 52 2022-IN-04
Вашите колеги от съседната лаборатория работят със специализирана система Fuga, която се базира
на два текстови файла – за автентификация (foo.pwd) и основен конфигурационен файл (foo.conf).
Двата файла би трябвало да се съхраняват в главната директория на системата, която ще наричаме
fuga.
24
На всеки ред във първия файл има потребителско име (малки латински букви) и паролата за този
потребител, разделени с двоеточие, като паролата не е в чист вид, а е хеширана.
Форматът на конфигурационния файл е недефиниран. Тъй като конфигурационният файл е твърде
голям за удобна работа, вашите колеги са решили да го разделят на части в отделни малки конфигурационни файлове, които държат в директория fuga/cfg и нейните под-директории. Всеки
такъв файл има име във формат bar.cfg, където bar е име на потребител на системата. Колегите
ви са написали скрипт (fuga/validate.sh), който приема един задължителен позиционен аргумент
– име на конфигурационен файл. Скриптът проверява указания конфигурационен файл за валиден
синтаксис и може да приключи с някой от следните exit code-ове:
• 0 – файлът е валиден;
• 1 – файлът не е валиден;
• 2 – настъпила е грешка при изпълнение на скрипта.
Ако файлът не е валиден, скриптът извежда на stdout редовете, на които има грешка, предхождани
от Line x: където x е номера на реда. В останалите случаи скриптът няма изход.
Разполагате с команда pwgen, която генерира и извежда на stdout случайни пароли (букви и цифри),
и знаете, че поддържа следните два аргумента: pwgen [password_length] [number_of_passwords]
Също така разполагате с командата mkpasswd, която по подаден аргумент – парола в чист вид
извежда нейният хеш на stdout.
Помогнете на колегите си, като напишете шел скрипт, който приема параметър – име на директория
fuga. Скриптът трябва да:
• извежда на stderr грешните редове от малките конфигурационни файлове, във формата извеждан от валидиращия скрипт, като всеки ред трябва да започва с името на конфигурационния файл и знак двоеточие ’:’;
• (ре-)генерира foo.conf като конкатенация на валидните малки конфигурационни файлове;
• провери за всеки валиден малък конфигурационен файл дали потребителят съществува в
автентификационния файл и ако не – да го добави по подходящия начин, като изведе на
stdout потребителското име и паролата в чист вид, разделени с двоеточие.
Зад. 53 2022-SE-01 Съвременните компютри могат да влизат в различни режими за енергоспестяване
(suspend) и излизат от този режим (wake-up) при настъпването на определени събития. Linux kernel
предоставя специален виртуален файл /proc/acpi/wakeup, чрез който може да се проверява или
променя настройката за “събуждане” при настъпване на различни събития, в общия случай - при
активност на някое устройство. Тъй като този файл е интерфейс към ядрото, “четенето” от файла
и “писането” във файла изглеждат различно.
За улеснение на задачата ще ползваме опростено описание на този файл.
Под whitespace разбираме произволна комбинация от табове и интервали. При четене от файла
изходът представлява четири колони, разделени с whitespace, в полетата не може да има whitespace;
първият ред е header на съответната колона. Примерно съдържание на файла:
Device S-state Status Sysfs node
GLAN S4 *enabled pci:0000:00:1f.6
XHC S3 *enabled pci:0000:00:14.0
XDCI S4 *disabled
LID S4 *enabled platform:PNP0C0D:00
HDAS S4 *disabled pci:0000:00:1f.3
RP01 S4 *enabled pci:0000:00:1c.0
където:
• първата колона дава уникално име на устройство, което може да събуди машината, като името
е ограничено до четири знака главни латински букви и цифри;
• третата колона описва дали това устройство може да събуди машината. Възможните стойности
са enabled/disabled, предхождани от звездичка;
• втората и четвъртата колона ги игнорираме в рамките на задачата.
При записване на име на устройство във файла /proc/acpi/wakeup, неговото състояние се променя
от disabled на enabled или обратно. Например, ако файлът изглежда както примера по-горе, при
25
запис на XHC в него, третият ред ще се промени на:
XHC S3 *disabled pci:0000:00:14.0
При запис на HDAS, шестият ред ще се промени на:
HDAS S4 *enabled pci:0000:00:1f.3
Дефиниран е формат на конфигурационен файл, който описва желан комплект от настройки на
wakeup събития. Примерен файл:
# comment bar
GLAN disabled
LID enabled # comment foo
където:
• знакът диез (#) е знак за коментар до края на реда;
• редовете би трябвало да са комбинация от име на устройство и желаното състояние на настройката за събуждане при събития от това устройство, разделени с whitespace.
Напишете скрипт, който при подаден първи параметър име на конфигурационен файл в горния
формат осигурява исканите настройки за събуждане. Ако във файла има ред за устройство, което не
съществува, скриптът да извежда предупреждение. Обърнете внимание на обработката за грешки
и съобщенията към потребителя – искаме скриптът да бъде удобен и валиден инструмент.
Зад. 54 2022-SE-02 Дефинирана е система за бекъпване на сървъри, която държи направените архиви
в главна директория (която ще наричаме fubar ), в която има четири под-директории за различни
класове бекъпи:
• 0 – съдържа годишни бекъпи
• 1 – съдържа месечни бекъпи
• 2 – съдържа седмични бекъпи
• 3 – съдържа дневни бекъпи
Всяка директория съдържа архивни файлове с имена във формат hostname-area-YYYYMMDD.tar.xz,
където:
• hostname е името на някаква машина, която е бекъпвана;
• area е типът бекъп за съответната машина;
• YYYYMMDD е датата, на която е направен бекъпа;
• никое от горните полета не може да съдържа тире или точка;
• някои от файловете могат да са symlink-ове.
Примерни имена на файлове:
astero-etc-20220323.tar.xz stratios-etc-20220428.tar.xz nestor-db-20220404.tar.xz
gila-srv-20220405.tar.xz catalyst-var-20220406.tar.xz drake-home-20220404.tar.xz
dominix-var-20220404.tar.xz
Комбинацията от hostname и area дефинира уникален обект за бекъпване. Всички архивни файлове са пълноценни бекъпи на даден обект и са достатъчни за неговото възстановяване при нужда
(заб. извън обхвата на задачата).
Ако даден файл е symlink, то той може да е валиден или счупен. Symlink-овете са създадени за
удобство и не ги считаме за пълноценни бекъпи.
Политиката ни за бекъп казва, че за да имаме валиден бекъп на даден обект, за него трябва да
имаме минимум 1 годишен, 2 месечни, 3 седмични и 4 дневни пълноценни бекъпа.
Важност:
• обектите са равни по важност помежду си;
• важността на класовете бекъпи е във възходящ ред по горния списък, т.е. при равни други
условия дневните бекъпи са по-ценни от седмичните и т.н.;
• в рамките на един клас бекъпи по-новите бекъпи са по-важни от по-старите.
26
Напишете shell скрипт, който приема два два задължителни позиционни аргумента – име на директория и число в интервала [1, 99]. Примерно извикване: ./foo.sh ./bar/ 30 където:
• директорията представлява главна директория (fubar ) на описаната система за бекпъване;
• числото дефинира колко процента е максималното допустимо използвано място на файловата
система, в която се намира подадената директория.
За удобство приемаме, че директорията fubar и всички обекти в нея се намират в една и съща
файлова система.
Упътване: Командата df извикана с аргумент име на файл/директория връща информация за
файловата система, в която той се намира. Пример:
$ df ./README.md
Filesystem 1K-blocks Used Available Use% Mounted on
/dev/mapper/o7-hm 100663296 61735732 37288764 63% /home
Скриптът трябва да изтрива минимален брой пълноценни архивни файлове така, че:
• всеки обект да има валиден бекъп;
• обръща внимание на описаните по-горе важности;
• процентите използвано място върху файловата система да е не повече от подаденият параметър (a ако това е невъзможно, скриптът да освободи колкото може повече място, без да
нарушава валидностите на бекъпите на обектите);
• не е допустимо след работата на скрипта да останат счупени symlink–ове.
Зад. 55 2023-CE-01
Трябва да напишете shell script, който работи с данни от наблюдения на звезди.
Скриптът приема два параметъра:
• Име на CSV файл, съдържащ данните
• Име на тип звезда (по-долу ще обясним за какво го ползваме)
Част от CSV файла изглежда така:
Hen 2-99,000-BDB-257,13 52 30.68 -66 23 26.6,Cir,PN,--,13.1
Nova Car 1971,--,10 39 47.12 -63 14 07.2,Car,NON-CV,--,--
WR 21a,000-BJP-528,10 25 56.50 -57 48 43.5,Car,WR,31.673,12.82
HD 109857,000-BKQ-240,12 39 14.58 -75 22 14.1,Mus,HMXB,--,6.48
Колонките са разделени със запетайки и имат следните значения:
1. Име на звездата
2. Идентификатор
3. Координати
4. Име на съзвездие
5. Тип на звездата
6. Период
7. Яркост (магнитуд)
• По-ярките звезди имат по-малка стойност за магнитуд
Скриптът трябва да извежда името на най-ярката звезда от съзвездието, в което има най-много
звезди от типа, подаден като втори параметър.
Липсващите стойности са обозначени с две тирета.
Зад. 56 2023-IN-01
Вашите колеги от съседната лаборатория имат няколко GNU/Linux машини със специфични RAID
контролери и ползват специализирана система за наблюдение Hugin. Помогнете на колегите си, като
напишете shell скрипт, който взима температурата на дисковете, закачени към тези контролери, и
генерира изход, удобен за ползване от системата за наблюдение.
За достъп до данните на дисковете, колегите ви казват, че root потребителя може да изпълни
следната команда, която взима информация от даден контролер:
27
ssacli ctrl slot=x pd all show detail
където x е номер на PCI слот, в който е включен контролера. Примерен изход от командата:
Smart Array P420i in Slot 0 (Embedded)
Array A
physicaldrive 1I:2:1
Rotational Speed: 15000
Current Temperature (C): 35
physicaldrive 1I:2:2
Interface Type: SAS
Current Temperature (C): 36
SMR Support: None
physicaldrive 1I:2:3
Status: OK
Drive Type: Spare Drive
Current Temperature (C): 34
Maximum Temperature (C): 42
Още един пример:
Smart Array P822 in Slot 1
Array J
physicaldrive 2E:1:19
Current Temperature (C): 29
physicaldrive 2E:1:20
Current Temperature (C): 28
Unassigned
physicaldrive 2E:1:21
Current Temperature (C): 30
physicaldrive 2E:1:22
Current Temperature (C): 29
Ако обобщим, изходът изглежда така:
• обща информация за контролера в съответния слот, и частност, модел на контролера (P420i/P822)
• една или повече секции на второ ниво, дефиниращи (нула или повече) масиви или (нула или
една) секция с неизползвани дискове (Array A/Array J/Unassigned), като буквата (A, J, ...)
дефинира името на масива в рамките на контролера
• във всяка такава секция има една или повече подсекции за дискове в съответния масив
(physicaldrive 1I:2:1, physicaldrive 2E:1:22, и т.н.), където низът след physicaldrive е
име на този диск в рамките на контролера
• във всяка подсекция за даден диск има множество параметри във вида key name: value като
за колегите ви е интересен само параметърът Current Temperature (C)
Нека въведем следните термини:
• идентификатор на диск – низ във вида “SSAcmmmappp”, където:
– SSA – литерал
– c – номер на слот
– mmm – модел на контролер
– a – име на масив или UN при неизползван диск
– ppp – име на диск, без двуеточия
• label на диск – низ във вида “SSAc mmm а qqq”, където
– qqq – име на диск
28
– останалите полета са по горната дефиниция
• забележка: кавичките не са част от идентификатора или от label-а на даден диск.
Възможно е да съществува environment променлива CTRLSLOTS, чиято стойност да е един или повече
номера на PCI слотове, разделени с интервали, и в този случай скриптът трябва да извежда информация от тези контролери. Ако такава променлива не е дефинирана, скриптът по подразбиране
да работи с контролера в слот 0.
Скриптът трябва да поддържа следните видове изпълнение:
• с един параметър autoconf – скриптът трябва да извежда низа yes
• с един параметър config – скриптът трябва да извежда следния изход:
graph_title SSA drive temperatures
graph_vlabel Celsius
graph_category sensors
graph_info This graph shows SSA drive temp
SSA0P420iA1I21.label SSA0 P420i A 1I:2:1
SSA0P420iA1I21.type GAUGE
SSA0P420iA1I22.label SSA0 P420i A 1I:2:2
SSA0P420iA1I22.type GAUGE
SSA0P420iA1I23.label SSA0 P420i A 1I:2:3
SSA0P420iA1I23.type GAUGE
SSA1P822J2E119.label SSA1 P822 J 2E:1:19
SSA1P822J2E119.type GAUGE
SSA1P822J2E120.label SSA1 P822 J 2E:1:20
SSA1P822J2E120.type GAUGE
SSA1P822UN2E121.label SSA1 P822 UN 2E:1:21
SSA1P822UN2E121.type GAUGE
SSA1P822UN2E122.label SSA1 P822 UN 2E:1:22
SSA1P822UN2E122.type GAUGE
• без параметри – скриптът трябва да извежда следния изход:
SSA0P420iA1I21.value 35
SSA0P420iA1I22.value 36
SSA0P420iA1I23.value 34
SSA1P822J2E119.value 29
SSA1P822J2E120.value 28
SSA1P822UN2E121.value 30
SSA1P822UN2E122.value 29
В горните изходи:
• низовете, започващи с graph са литерали
• низовете, в които се среща .label, .type или .value започват с идентификатор на диск
• низът след .label е label на диск
• .type винаги е GAUGE
• числото след .value е температурата на въпросния диск
Зад. 57 2023-IN-02
Вашите колеги от съседната лаборатория ползват специализиран софтуер за оптометрични изследвания, който записва резултатите от всяко измерване в отделен файл. Файловете имат уникално
съдържание, по което се определя за кое измерване се отнася файла. За съжаление, тъй като колегите ви ползват бета версия на софтуера, той понякога записва по няколко пъти резултатите от
дадено измерване в произволна комбинация от следните варианти:
• нула или повече отделни обикновенни файла с еднакво съдържание;
• нула или повече групи от hardlink-ове, като всяка група съдържа две или повече имена на
даден файл с измервания.
Помогнете на колегите си, като напишете shell скрипт, който приема параметър – име на директория,
съдържаща файлове с измервания. Скриптът трябва да извежда на стандартния изход списък с
имена на файлове, кандидати за изтриване, по следните критерии:
29
• ако измерването е записано само в отделни файлове, трябва да остане един от тях;
• ако измерването е записано само в групи от hardlink-ове, всяка група трябва да се намали с
едно име;
• ако измерването е записано и в групи, и като отделни файлове, за групите се ползва горния
критерий, а всички отделни файлове се премахват.
Зад. 58 2023-SE-01
Напишете скрипт, който цензурира всички срещания на “забранени” думи в дадени текстове.
Примерно извикване: ./redact.sh bad_words.lst ./my_texts.
Първият аргумент на скрипта е име на текстов файл, съдържащ по една забранена дума на ред:
cake
cakes
shake
banana
pine_apple42
shakinator
Вторият аргумент е име на директория: интересуват ни всички файлове в нея и в нейните поддиректории, чиито имена завършват на .txt.
Скриптът ви трябва да подмени всички срещания на забранени думи във въпросните файлове с
брой звездички, съответстващ на дължината на думата. Подменят се само цели срещания на думи.
Например, ако имаме файл ./my_texts/shake.txt със съдържание:
to make banana shake, we start by blending four bananas.
след изпълнение на скрипта, съдържанието му трябва да е:
to make ****** *****, we start by blending four bananas.
Под “дума” разбираме последователност от букви, цифри и долни черти.
За улеснение, може да приемете, че разглеждаме само малки букви (никъде не се срещат главни
букви).
За бонус точки: премахнете улесненито, правейки операцията по цензуриране case-insensitive
(файлът със забранени думи пак съдържа само малки букви, но в текстовете могат да се срещнат варианти на думите с произволни комбинации от малки и главни букви): ако в примерния
текст се срещне думата BaNaNa, тя трябва да бъде заменена с ******, защото banana е забранена
дума.
Зад. 59 2023-SE-02
Задачата ви е да напишете скрипт benchmark.sh, който измерва средното време за изпълнение на
дадена команда. Първият аргумент на скрипта е число (време за провеждане на експеримента, в
секунди), а останалите аргументи на скрипта са измерваната команда и нейните аргументи.
Скриптът трябва да изпълнява подадената команда многократно, докато изтече подаденото време.
Когато това се случи, скриптът трябва да изчака последното извикване на командата да приключи и
да изведе съобщение, описващо броя направени извиквания, общото и средното време за изпълнение.
$ ./benchmark.sh 60 convert image.jpg result.png
Ran the command ’convert image.jpg result.png’ 8 times for 63 seconds.
Average runtime: 7.88 seconds.
$ ./benchmark.sh 10 sleep 1.5
Ran the command ’sleep 1.5’ 7 times for 10.56 seconds.
Average runtime: 1.51 seconds.
30
Забележки:
• Времената се извеждат в секунди, с точност два знака след запетайката.
• Приемете, че времето на изпълнение на частите от скрипта извън подадената команда е пренабрежимо малко.
Зад. 60 2023-SE-03
При статистическа обработка на текстове често се налага да имаме списък от думи (наречени
“стоп-думи”), които се срещат прекалено често и не носят стойност за изследването. Такива думи
са например “you”, “then”, “for” и т.н.
Напишете скрипт stopword_candidates.sh, който приема като аргумент име на директория и извежда 10-те думи, които най-много изглеждат като стоп-думи.
• За да бъде стоп-дума, трябва броят файлове, които я съдържат ≥ 3 пъти да е ≥
общия брой файлове
2
• Една дума е по-добър кандидат от друга, ако има по-голям общ брой срещания във всички
файлове
Забележки:
• Под “всички файлове” имаме предвид всички обикновени файлове в дадената директория и
нейните поддиректории
• Под “дума” имаме предвид непрекъсната последователност от латински букви (a-z) - всички
останали символи не са част от думите
• За улеснение може да приемете, че във файловете няма главни букви
Зад. 61 2023-SE-04
Напишете скрипт, който открива еднакви по съдържание файлове в дадена директория и използва
тази информация, за да намали заетото място на диска.
Скриптът приема един параметър — име на директория. Примерно извикване: ./dedup.sh ./my-dir
Скриптът трябва да направи две неща:
• ако има файлове с еднакво съдържание, да направи така, че имената на тези файлове да сочат
към едно и също копие на съответните данни
• да изведе съобщение, съдържащо следната информация:
– колко групи файлове са дедупликирани
– колко байта от мястото на диска се е освободило
Забележки:
• считаме, че цялата дадена директория се намира върху една файлова система
• ако два файла имат еднакви хеш-суми, считаме, че са еднакви по съдържание

Зад. 49 2022-IN-01
Както знаете, при отваряне на файл с редактора vi, той създава в същата директория временен
файл с име в следния формат: точка, името на оригиналния файл, точка, swp. Например, при
редактиране на файл с име foo.txt ще се създаде временен файл с име .foo.txt.swp.
Напишете shell скрипт, който приема два задължителни позиционни аргумента – имена на директории. Примерно извикване: ./foo.sh ./dir1 /path/to/dir2/
В dir1 може да има файлове/директории, директорията dir2 трябва да е празна.
Скриптът трябва да копира всички обикновенни файлове от dir1 (и нейните под-директории) в
dir2, запазвайки директорийната структура, но без да копира временните файлове, създадени от
редактора vi (по горната дефиниция).
Забележка: За удобство приемаме, че не ни вълнува дали метаданните на обектите (owner, group,
permissions, etc.) ще се запазят.
Примерни обекти:
dir1/
dir1/a
dir1/.a.swp
dir1/b
dir1/c/d
dir1/c/.bar.swp
Обекти след изпълнението:
dir2/
dir2/a
dir2/b
dir2/c/d
dir2/c/.bar.swp
Зад. 50 2022-IN-02
Името на дадена машина можете да вземете с командата hostname -s.
Разполагате с машина, на която е инсталиран специализиран софтуер, който ползва два потребителски акаунта – oracle и grid.
Всеки от потребителите би трябвало да има environment променлива ORACLE_BASE, която указва
абсолютен път до директория във формат /път/до/дир.
Всеки от потребителите би трябвало да има environment променлива ORACLE_HOME, която указва
абсолютен път до директория във формат /път/до/дир. В поддиректорията bin на зададената
директория би трябвало да има изпълним файл с име sqlplus.
Всеки от потребителите би трябвало да има environment променлива ORACLE_SID с някакъв низ
като стойност.
Ако горните три environment променливи съществуват, всеки от потребителите може да изпълнява
неговото копие на командата sqlplus със следните параметри: sqlplus -SL "/ as роля" @foo.sql
където роля трябва да бъде низът SYSDBA при изпълнение от oracle и SYSASM при изпълнение от
grid. И в двата случая sqlplus изпълнява SQL заявките от файла (foo.sql, името на файла няма
значение) и извежда изхода на stdout. Ако съдържанието на sql файла е:
SELECT value FROM v$parameter WHERE name = ’diagnostic_dest’;
EXIT;
изходът ще бъде стойността на търсения параметър diagnostic_dest в следния вид:
oracle@astero:~$ sqlplus -SL "/ as sysdba" @a.sql

VALUE
--------------------------------------------------------------------------------
/u01/app/oracle
oracle@astero:~$
Параметърът diagnostic_dest може да няма стойност, в който случай изведеният низ ще е празен.
Изходът винаги е 5 реда, стойността винаги е на 4-и ред. Ако командата sqlplus не се изпълни
успешно, тя ще върне ненулев exit code.
За всеки от двата акаунта съществува директория, която ще наричаме diag_base. Конкретната
директория е:
• същата като ORACLE_BASE, ако diagnostic_dest няма стойност
• същата като diagnostic_dest, ако diagnostic_dest има стойност
За всеки от двата акаунта би трябвало да съществува под-директория на diag_base с име diag,
която ще наричаме diag_dir.
Съществуват три множества интересни за нас файлове:
• множество crs – за потребител grid, в diag_dir има под-директория crs, в която има поддиректория с името на машината, в която има под-директория crs, в която има под-директория
trace. Интересни за нас файлове в тази директория са такива, чието име завършва на
подчертавка-число и имат разширение trc или trm, например foo_356.trc, bar_40001.trm.
• множество tnslsnr – за потребител grid, в diag_dir има под-директория tnslsnr, в която има
под-директория с името на машината, в която има няколко директории с различни имена. Във
всяка от тези директории има под-директории alert и trace. Интересни за нас са файловете
в alert, чието име завършва на подчертавка-число и имат разширение xml (напр. baz_78.xml)
и файловете в trace, чието име завършва на подчертавка-число и имат разширение log (напр.
qux_88231.log).
• множество rdbms – за потребител oracle, в diag_dir има под-директория rdbms, в която има
няколко под-директории, във всяка от които може да има няколко под-директории. Интересни за нас са само файловете в тези директории на второ ниво, чието име завършва на
подчертавка-число и имат разширение trc или trm, например corge_27.trc, grault_1024.trm.
Напишете скрипт, който може да се изпълнява само от някой от тези два акаунта, и приема задължителен първи позиционен аргумент число (в дни). В зависимост от това кой потребител изпълнява
скрипта, той трябва да извежда на stdout за всяко множество на съответния потребител общият
размер (в килобайти) на описаните по-горе интересни файлове за които времето на последната
промяна (по съдържание) на файла е по-голямо от зададеното като параметър на скрипта.
Примерно изпълнение и изход:
oracle@astero:~$ ./foo.sh 42
rdbms: 14400
grid@astero:~$ ./foo.sh 73
crs: 28800
tnslsnr: 33600
Забележка: Правилното ползване на временни файлове е разрешено.
Зад. 51 2022-IN-03 Вашите колеги от съседната лаборатория работят по проект, в който до сега се е
ползвала нестандартна имплементация на командата java. По време на миграцията с цел използване на стандартна имплементация на командата се оказало, че на много места командата се
вика по стария, грешен начин, който вече е невалиден. Вашата задача е да напишете shell скрипт
iwojima.sh, който работи подобно на старата имплементация на java, но вътрешно вика новата
имплементация по правилния начин.
Файловият формат JAR (Java ARchive) представлява пакет, който обединява няколко Java class
файлове, допълнителни мета-данни и различни ресурси. Файлове в този формат обикновенно (но
не задължително) имат разширение .jar. Част от метаданните във файла указват кой е главният

клас, чийто метод main() се изпълнява по подразбиране. Въпросният main() метод ще получи списък
с аргументите, указани при извикването на командата java (подобно на main() функцията в езика
C).
Едно от извикванията на стандартната имплементация на командата java (единственото, което разглеждаме в тази задача) има следният синтаксис: java [options] -jar filename [args]
където:
• options – незадължителна поредица от опции на командата java, разделени с интервал; всяка
опция задължително започва с тире;
• filename – име на JAR файл, който да бъде изпълнен, използва се винаги с опция -jar;
• args – незадължителни аргументи, с които ще бъде стартиран main() методът на класа по
подразбиране (аргументи на самата Java програма).
Като пример разполагаме с JAR файл (app.jar), с един клас в него, чийто main() метод реализира
единствено функционалност, еквивалента на следният bash код:
if [ -z "${qux}" ]; then
qux=default
fi
echo "${qux}"
Общият вид на изпълнение с командата java би бил:
$ java -jar ./app.jar
default
Една от стандартните опции на командата java е -Dproperty=value, с което се дефинира променлива с име property и със стойност value. При нужда от няколко променливи, за всяка се ползва
отделна опция -D. Пример за правилно ползване на опцията в стандартната имплементация:
$ java -Dqux=foo -jar /path/to/app.jar
foo
За съжаление, нестандартната имплементация на java, която е ползвана до момента, работи по
друг начин. Пример:
$ java -jar ./app.jar -Dqux=foo
default
$ java -Dqux=foo -jar ./app.jar -hoge fuga
default
$ java -jar -Dqux=foo app.jar
foo
Ако трябва да обобщим как работи нестандартната имплементация:
• всичко след името на JAR файла са аргументи за main() метода (напр. -hoge и fuga);
• името на JAR файла е някъде след опцията -jar;
• опции за java командата може да има и преди, и след опцията -jar;
• опцията -Dproperty=value работи само ако е след опцията -jar.
Забележки: Вашият скрипт iwojima.sh няма нужда да поддържа извиквания, които не подават
опция -jar. За удобство приемаме, че опциите (вкл. property и value), имената на JAR файловете
и аргументите не могат да съдържат интервали.
Зад. 52 2022-IN-04
Вашите колеги от съседната лаборатория работят със специализирана система Fuga, която се базира
на два текстови файла – за автентификация (foo.pwd) и основен конфигурационен файл (foo.conf).
Двата файла би трябвало да се съхраняват в главната директория на системата, която ще наричаме
fuga.

На всеки ред във първия файл има потребителско име (малки латински букви) и паролата за този
потребител, разделени с двоеточие, като паролата не е в чист вид, а е хеширана.
Форматът на конфигурационния файл е недефиниран. Тъй като конфигурационният файл е твърде
голям за удобна работа, вашите колеги са решили да го разделят на части в отделни малки конфигурационни файлове, които държат в директория fuga/cfg и нейните под-директории. Всеки
такъв файл има име във формат bar.cfg, където bar е име на потребител на системата. Колегите
ви са написали скрипт (fuga/validate.sh), който приема един задължителен позиционен аргумент
– име на конфигурационен файл. Скриптът проверява указания конфигурационен файл за валиден
синтаксис и може да приключи с някой от следните exit code-ове:
• 0 – файлът е валиден;
• 1 – файлът не е валиден;
• 2 – настъпила е грешка при изпълнение на скрипта.
Ако файлът не е валиден, скриптът извежда на stdout редовете, на които има грешка, предхождани
от Line x: където x е номера на реда. В останалите случаи скриптът няма изход.
Разполагате с команда pwgen, която генерира и извежда на stdout случайни пароли (букви и цифри),
и знаете, че поддържа следните два аргумента: pwgen [password_length] [number_of_passwords]
Също така разполагате с командата mkpasswd, която по подаден аргумент – парола в чист вид
извежда нейният хеш на stdout.
Помогнете на колегите си, като напишете шел скрипт, който приема параметър – име на директория
fuga. Скриптът трябва да:
• извежда на stderr грешните редове от малките конфигурационни файлове, във формата извеждан от валидиращия скрипт, като всеки ред трябва да започва с името на конфигурационния файл и знак двоеточие ’:’;
• (ре-)генерира foo.conf като конкатенация на валидните малки конфигурационни файлове;
• провери за всеки валиден малък конфигурационен файл дали потребителят съществува в
автентификационния файл и ако не – да го добави по подходящия начин, като изведе на
stdout потребителското име и паролата в чист вид, разделени с двоеточие.
Зад. 53 2022-SE-01 Съвременните компютри могат да влизат в различни режими за енергоспестяване
(suspend) и излизат от този режим (wake-up) при настъпването на определени събития. Linux kernel
предоставя специален виртуален файл /proc/acpi/wakeup, чрез който може да се проверява или
променя настройката за “събуждане” при настъпване на различни събития, в общия случай - при
активност на някое устройство. Тъй като този файл е интерфейс към ядрото, “четенето” от файла
и “писането” във файла изглеждат различно.
За улеснение на задачата ще ползваме опростено описание на този файл.
Под whitespace разбираме произволна комбинация от табове и интервали. При четене от файла
изходът представлява четири колони, разделени с whitespace, в полетата не може да има whitespace;
първият ред е header на съответната колона. Примерно съдържание на файла:
Device S-state Status Sysfs node
GLAN S4 *enabled pci:0000:00:1f.6
XHC S3 *enabled pci:0000:00:14.0
XDCI S4 *disabled
LID S4 *enabled platform:PNP0C0D:00
HDAS S4 *disabled pci:0000:00:1f.3
RP01 S4 *enabled pci:0000:00:1c.0
където:
• първата колона дава уникално име на устройство, което може да събуди машината, като името
е ограничено до четири знака главни латински букви и цифри;
• третата колона описва дали това устройство може да събуди машината. Възможните стойности
са enabled/disabled, предхождани от звездичка;
• втората и четвъртата колона ги игнорираме в рамките на задачата.
При записване на име на устройство във файла /proc/acpi/wakeup, неговото състояние се променя
от disabled на enabled или обратно. Например, ако файлът изглежда както примера по-горе, при

запис на XHC в него, третият ред ще се промени на:
XHC S3 *disabled pci:0000:00:14.0
При запис на HDAS, шестият ред ще се промени на:
HDAS S4 *enabled pci:0000:00:1f.3
Дефиниран е формат на конфигурационен файл, който описва желан комплект от настройки на
wakeup събития. Примерен файл:
# comment bar
GLAN disabled
LID enabled # comment foo
където:
• знакът диез (#) е знак за коментар до края на реда;
• редовете би трябвало да са комбинация от име на устройство и желаното състояние на настройката за събуждане при събития от това устройство, разделени с whitespace.
Напишете скрипт, който при подаден първи параметър име на конфигурационен файл в горния
формат осигурява исканите настройки за събуждане. Ако във файла има ред за устройство, което не
съществува, скриптът да извежда предупреждение. Обърнете внимание на обработката за грешки
и съобщенията към потребителя – искаме скриптът да бъде удобен и валиден инструмент.
Зад. 54 2022-SE-02 Дефинирана е система за бекъпване на сървъри, която държи направените архиви
в главна директория (която ще наричаме fubar ), в която има четири под-директории за различни
класове бекъпи:
• 0 – съдържа годишни бекъпи
• 1 – съдържа месечни бекъпи
• 2 – съдържа седмични бекъпи
• 3 – съдържа дневни бекъпи
Всяка директория съдържа архивни файлове с имена във формат hostname-area-YYYYMMDD.tar.xz,
където:
• hostname е името на някаква машина, която е бекъпвана;
• area е типът бекъп за съответната машина;
• YYYYMMDD е датата, на която е направен бекъпа;
• никое от горните полета не може да съдържа тире или точка;
• някои от файловете могат да са symlink-ове.
Примерни имена на файлове:
astero-etc-20220323.tar.xz stratios-etc-20220428.tar.xz nestor-db-20220404.tar.xz
gila-srv-20220405.tar.xz catalyst-var-20220406.tar.xz drake-home-20220404.tar.xz
dominix-var-20220404.tar.xz
Комбинацията от hostname и area дефинира уникален обект за бекъпване. Всички архивни файлове са пълноценни бекъпи на даден обект и са достатъчни за неговото възстановяване при нужда
(заб. извън обхвата на задачата).
Ако даден файл е symlink, то той може да е валиден или счупен. Symlink-овете са създадени за
удобство и не ги считаме за пълноценни бекъпи.
Политиката ни за бекъп казва, че за да имаме валиден бекъп на даден обект, за него трябва да
имаме минимум 1 годишен, 2 месечни, 3 седмични и 4 дневни пълноценни бекъпа.
Важност:
• обектите са равни по важност помежду си;
• важността на класовете бекъпи е във възходящ ред по горния списък, т.е. при равни други
условия дневните бекъпи са по-ценни от седмичните и т.н.;
• в рамките на един клас бекъпи по-новите бекъпи са по-важни от по-старите.

Напишете shell скрипт, който приема два два задължителни позиционни аргумента – име на директория и число в интервала [1, 99]. Примерно извикване: ./foo.sh ./bar/ 30 където:
• директорията представлява главна директория (fubar ) на описаната система за бекпъване;
• числото дефинира колко процента е максималното допустимо използвано място на файловата
система, в която се намира подадената директория.
За удобство приемаме, че директорията fubar и всички обекти в нея се намират в една и съща
файлова система.
Упътване: Командата df извикана с аргумент име на файл/директория връща информация за
файловата система, в която той се намира. Пример:
$ df ./README.md
Filesystem 1K-blocks Used Available Use% Mounted on
/dev/mapper/o7-hm 100663296 61735732 37288764 63% /home
Скриптът трябва да изтрива минимален брой пълноценни архивни файлове така, че:
• всеки обект да има валиден бекъп;
• обръща внимание на описаните по-горе важности;
• процентите използвано място върху файловата система да е не повече от подаденият параметър (a ако това е невъзможно, скриптът да освободи колкото може повече място, без да
нарушава валидностите на бекъпите на обектите);
• не е допустимо след работата на скрипта да останат счупени symlink–ове.
Зад. 55 2023-CE-01
Трябва да напишете shell script, който работи с данни от наблюдения на звезди.
Скриптът приема два параметъра:
• Име на CSV файл, съдържащ данните
• Име на тип звезда (по-долу ще обясним за какво го ползваме)
Част от CSV файла изглежда така:
Hen 2-99,000-BDB-257,13 52 30.68 -66 23 26.6,Cir,PN,--,13.1
Nova Car 1971,--,10 39 47.12 -63 14 07.2,Car,NON-CV,--,--
WR 21a,000-BJP-528,10 25 56.50 -57 48 43.5,Car,WR,31.673,12.82
HD 109857,000-BKQ-240,12 39 14.58 -75 22 14.1,Mus,HMXB,--,6.48
Колонките са разделени със запетайки и имат следните значения:
1. Име на звездата
2. Идентификатор
3. Координати
4. Име на съзвездие
5. Тип на звездата
6. Период
7. Яркост (магнитуд)
• По-ярките звезди имат по-малка стойност за магнитуд
Скриптът трябва да извежда името на най-ярката звезда от съзвездието, в което има най-много
звезди от типа, подаден като втори параметър.
Липсващите стойности са обозначени с две тирета.
Зад. 56 2023-IN-01
Вашите колеги от съседната лаборатория имат няколко GNU/Linux машини със специфични RAID
контролери и ползват специализирана система за наблюдение Hugin. Помогнете на колегите си, като
напишете shell скрипт, който взима температурата на дисковете, закачени към тези контролери, и
генерира изход, удобен за ползване от системата за наблюдение.
За достъп до данните на дисковете, колегите ви казват, че root потребителя може да изпълни
следната команда, която взима информация от даден контролер:

ssacli ctrl slot=x pd all show detail
където x е номер на PCI слот, в който е включен контролера. Примерен изход от командата:
Smart Array P420i in Slot 0 (Embedded)
Array A
physicaldrive 1I:2:1
Rotational Speed: 15000
Current Temperature (C): 35
physicaldrive 1I:2:2
Interface Type: SAS
Current Temperature (C): 36
SMR Support: None
physicaldrive 1I:2:3
Status: OK
Drive Type: Spare Drive
Current Temperature (C): 34
Maximum Temperature (C): 42
Още един пример:
Smart Array P822 in Slot 1
Array J
physicaldrive 2E:1:19
Current Temperature (C): 29
physicaldrive 2E:1:20
Current Temperature (C): 28
Unassigned
physicaldrive 2E:1:21
Current Temperature (C): 30
physicaldrive 2E:1:22
Current Temperature (C): 29
Ако обобщим, изходът изглежда така:
• обща информация за контролера в съответния слот, и частност, модел на контролера (P420i/P822)
• една или повече секции на второ ниво, дефиниращи (нула или повече) масиви или (нула или
една) секция с неизползвани дискове (Array A/Array J/Unassigned), като буквата (A, J, ...)
дефинира името на масива в рамките на контролера
• във всяка такава секция има една или повече подсекции за дискове в съответния масив
(physicaldrive 1I:2:1, physicaldrive 2E:1:22, и т.н.), където низът след physicaldrive е
име на този диск в рамките на контролера
• във всяка подсекция за даден диск има множество параметри във вида key name: value като
за колегите ви е интересен само параметърът Current Temperature (C)
Нека въведем следните термини:
• идентификатор на диск – низ във вида “SSAcmmmappp”, където:
– SSA – литерал
– c – номер на слот
– mmm – модел на контролер
– a – име на масив или UN при неизползван диск
– ppp – име на диск, без двуеточия
• label на диск – низ във вида “SSAc mmm а qqq”, където
– qqq – име на диск

– останалите полета са по горната дефиниция
• забележка: кавичките не са част от идентификатора или от label-а на даден диск.
Възможно е да съществува environment променлива CTRLSLOTS, чиято стойност да е един или повече
номера на PCI слотове, разделени с интервали, и в този случай скриптът трябва да извежда информация от тези контролери. Ако такава променлива не е дефинирана, скриптът по подразбиране
да работи с контролера в слот 0.
Скриптът трябва да поддържа следните видове изпълнение:
• с един параметър autoconf – скриптът трябва да извежда низа yes
• с един параметър config – скриптът трябва да извежда следния изход:
graph_title SSA drive temperatures
graph_vlabel Celsius
graph_category sensors
graph_info This graph shows SSA drive temp
SSA0P420iA1I21.label SSA0 P420i A 1I:2:1
SSA0P420iA1I21.type GAUGE
SSA0P420iA1I22.label SSA0 P420i A 1I:2:2
SSA0P420iA1I22.type GAUGE
SSA0P420iA1I23.label SSA0 P420i A 1I:2:3
SSA0P420iA1I23.type GAUGE
SSA1P822J2E119.label SSA1 P822 J 2E:1:19
SSA1P822J2E119.type GAUGE
SSA1P822J2E120.label SSA1 P822 J 2E:1:20
SSA1P822J2E120.type GAUGE
SSA1P822UN2E121.label SSA1 P822 UN 2E:1:21
SSA1P822UN2E121.type GAUGE
SSA1P822UN2E122.label SSA1 P822 UN 2E:1:22
SSA1P822UN2E122.type GAUGE
• без параметри – скриптът трябва да извежда следния изход:
SSA0P420iA1I21.value 35
SSA0P420iA1I22.value 36
SSA0P420iA1I23.value 34
SSA1P822J2E119.value 29
SSA1P822J2E120.value 28
SSA1P822UN2E121.value 30
SSA1P822UN2E122.value 29
В горните изходи:
• низовете, започващи с graph са литерали
• низовете, в които се среща .label, .type или .value започват с идентификатор на диск
• низът след .label е label на диск
• .type винаги е GAUGE
• числото след .value е температурата на въпросния диск

Зад. 57 2023-IN-02
Вашите колеги от съседната лаборатория ползват специализиран софтуер за оптометрични изследвания, който записва резултатите от всяко измерване в отделен файл. Файловете имат уникално
съдържание, по което се определя за кое измерване се отнася файла. За съжаление, тъй като колегите ви ползват бета версия на софтуера, той понякога записва по няколко пъти резултатите от
дадено измерване в произволна комбинация от следните варианти:
• нула или повече отделни обикновенни файла с еднакво съдържание;
• нула или повече групи от hardlink-ове, като всяка група съдържа две или повече имена на
даден файл с измервания.
Помогнете на колегите си, като напишете shell скрипт, който приема параметър – име на директория,
съдържаща файлове с измервания. Скриптът трябва да извежда на стандартния изход списък с
имена на файлове, кандидати за изтриване, по следните критерии:

• ако измерването е записано само в отделни файлове, трябва да остане един от тях;
• ако измерването е записано само в групи от hardlink-ове, всяка група трябва да се намали с
едно име;
• ако измерването е записано и в групи, и като отделни файлове, за групите се ползва горния
критерий, а всички отделни файлове се премахват.
Зад. 58 2023-SE-01
Напишете скрипт, който цензурира всички срещания на “забранени” думи в дадени текстове.
Примерно извикване: ./redact.sh bad_words.lst ./my_texts.
Първият аргумент на скрипта е име на текстов файл, съдържащ по една забранена дума на ред:
cake
cakes
shake
banana
pine_apple42
shakinator
Вторият аргумент е име на директория: интересуват ни всички файлове в нея и в нейните поддиректории, чиито имена завършват на .txt.
Скриптът ви трябва да подмени всички срещания на забранени думи във въпросните файлове с
брой звездички, съответстващ на дължината на думата. Подменят се само цели срещания на думи.
Например, ако имаме файл ./my_texts/shake.txt със съдържание:
to make banana shake, we start by blending four bananas.
след изпълнение на скрипта, съдържанието му трябва да е:
to make ****** *****, we start by blending four bananas.
Под “дума” разбираме последователност от букви, цифри и долни черти.
За улеснение, може да приемете, че разглеждаме само малки букви (никъде не се срещат главни
букви).
За бонус точки: премахнете улесненито, правейки операцията по цензуриране case-insensitive
(файлът със забранени думи пак съдържа само малки букви, но в текстовете могат да се срещнат варианти на думите с произволни комбинации от малки и главни букви): ако в примерния
текст се срещне думата BaNaNa, тя трябва да бъде заменена с ******, защото banana е забранена
дума.
Зад. 59 2023-SE-02
Задачата ви е да напишете скрипт benchmark.sh, който измерва средното време за изпълнение на
дадена команда. Първият аргумент на скрипта е число (време за провеждане на експеримента, в
секунди), а останалите аргументи на скрипта са измерваната команда и нейните аргументи.
Скриптът трябва да изпълнява подадената команда многократно, докато изтече подаденото време.
Когато това се случи, скриптът трябва да изчака последното извикване на командата да приключи и
да изведе съобщение, описващо броя направени извиквания, общото и средното време за изпълнение.
$ ./benchmark.sh 60 convert image.jpg result.png
Ran the command ’convert image.jpg result.png’ 8 times for 63 seconds.
Average runtime: 7.88 seconds.
$ ./benchmark.sh 10 sleep 1.5
Ran the command ’sleep 1.5’ 7 times for 10.56 seconds.
Average runtime: 1.51 seconds.
30
Забележки:
• Времената се извеждат в секунди, с точност два знака след запетайката.
• Приемете, че времето на изпълнение на частите от скрипта извън подадената команда е пренабрежимо малко.
Зад. 60 2023-SE-03
При статистическа обработка на текстове често се налага да имаме списък от думи (наречени
“стоп-думи”), които се срещат прекалено често и не носят стойност за изследването. Такива думи
са например “you”, “then”, “for” и т.н.
Напишете скрипт stopword_candidates.sh, който приема като аргумент име на директория и извежда 10-те думи, които най-много изглеждат като стоп-думи.
• За да бъде стоп-дума, трябва броят файлове, които я съдържат ≥ 3 пъти да е ≥
общия брой файлове
2
• Една дума е по-добър кандидат от друга, ако има по-голям общ брой срещания във всички
файлове
Забележки:
• Под “всички файлове” имаме предвид всички обикновени файлове в дадената директория и
нейните поддиректории
• Под “дума” имаме предвид непрекъсната последователност от латински букви (a-z) - всички
останали символи не са част от думите
• За улеснение може да приемете, че във файловете няма главни букви
Зад. 61 2023-SE-04
Напишете скрипт, който открива еднакви по съдържание файлове в дадена директория и използва
тази информация, за да намали заетото място на диска.
Скриптът приема един параметър — име на директория. Примерно извикване: ./dedup.sh ./my-dir
Скриптът трябва да направи две неща:
• ако има файлове с еднакво съдържание, да направи така, че имената на тези файлове да сочат
към едно и също копие на съответните данни
• да изведе съобщение, съдържащо следната информация:
– колко групи файлове са дедупликирани
– колко байта от мястото на диска се е освободило
Забележки:
• считаме, че цялата дадена директория се намира върху една файлова система
• ако два файла имат еднакви хеш-суми, считаме, че са еднакви по съдържание

